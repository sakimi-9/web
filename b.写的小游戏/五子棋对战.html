<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <title>五子棋小游戏</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial;
        }

        h1 {
            margin-top: 20px;
        }

        #board {
            position: relative;
            margin: 20px 0;
            background: #b58863;
            border: 2px solid #333;
            transition: box-shadow 0.3s, width 0.3s, height 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .line {
            position: absolute;
            background: #333;
        }

        .h-line {
            height: 2px;
            width: 100%;
        }

        .v-line {
            width: 2px;
            height: 100%;
        }

        .piece {
            position: absolute;
            width: 26px;
            height: 26px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        .piece.black {
            background: #222;
        }

        .piece.white {
            background: #fff;
            border: 1px solid #aaa;
        }

        .piece.last {
            box-shadow: 0 0 0 3px #ff0, 0 0 8px 2px #f80;
            z-index: 2;
        }

        #status {
            margin-bottom: 10px;
            font-size: 18px;
        }

        #restart {
            padding: 6px 18px;
            font-size: 16px;
            cursor: pointer;
        }

        #mode-select {
            margin-bottom: 10px;
            font-size: 16px;
        }

        #undo {
            padding: 6px 18px;
            font-size: 16px;
            margin-left: 10px;
            cursor: pointer;
        }

        #subtitle {
            color: #e74c3c;
            font-size: 20px;
            margin-bottom: 10px;
            min-height: 24px;
            transition: opacity 0.5s;
        }

        #chess-record {
            margin-top: 10px;
            font-size: 14px;
            max-height: 180px;
            overflow-y: auto;
            background: #f8f8f8;
            border: 1px solid #ccc;
            padding: 6px;
            width: 90%;
        }

        #size-select {
            margin-bottom: 10px;
            font-size: 16px;
            margin-left: 10px;
        }

        #board.undomove {
            box-shadow: 0 0 16px 4px #4fc3f7;
        }

        #ai-mode-controls {
            display: none;
            margin-bottom: 10px;
        }

        #ai-controls {
            display: none;
            margin-bottom: 10px;
        }

        #ai-controls button,
        #ai-controls select {
            margin-right: 8px;
            font-size: 15px;
            padding: 4px 12px;
        }
    </style>
</head>

<body>
    <h1>五子棋小游戏</h1>
    <select id="mode-select">
        <option value="pvp">玩家对玩家</option>
        <option value="pve">玩家对电脑</option>
        <option value="aivai">AI对战</option>
    </select>
    <select id="size-select">
        <option value="11">小棋盘(11x11)</option>
        <option value="15" selected>中棋盘(15x15)</option>
        <option value="19">大棋盘(19x19)</option>
    </select>
    <div id="subtitle"></div>
    <div id="ai-mode-controls" style="display:none; margin-bottom:10px;">
        <button id="ai-toggle-mode">切换为手动下一步</button>
    </div>
    <div id="ai-controls" style="display:none; margin-bottom:10px;">
        <button id="ai-next">下一步</button>
        <button id="ai-speed">加速</button>
        <select id="ai-style">
            <option value="balance">均衡型</option>
            <option value="attack">进攻型</option>
            <option value="defense">防守型</option>
        </select>
    </div>
    <div id="status">黑棋先手</div>
    <div id="board"></div>
    <button id="restart">重新开始</button>
    <button id="undo">悔棋</button>
    <div id="chess-record"></div>
    <script>
        let size = 15;
        let board = [];
        let current = 1; // 1: 黑棋, 2: 白棋
        let gameOver = false;
        let mode = 'pvp';
        let moveHistory = [];
        let startTime = null;
        let endTime = null;
        let undoCount = 0;
        let lastMove = null;
        const boardDiv = document.getElementById('board');
        const statusDiv = document.getElementById('status');
        const restartBtn = document.getElementById('restart');
        const modeSelect = document.getElementById('mode-select');
        const undoBtn = document.getElementById('undo');
        const subtitleDiv = document.getElementById('subtitle');
        const cellSize = 32;
        let offset = cellSize / 2;
        const recordDiv = document.getElementById('chess-record');
        let aiInterval = null;
        let aiSpeed = 400;
        let aiAuto = true; // true: 自动对战, false: 手动下一步
        let aiStyle = 'balance';

        function updateBoardSize() {
            boardDiv.style.width = (cellSize * (size - 1) + cellSize) + 'px';
            boardDiv.style.height = (cellSize * (size - 1) + cellSize) + 'px';
        }

        function drawBoard() {
            updateBoardSize();
            boardDiv.innerHTML = '';
            // 画横线
            for (let i = 0; i < size; i++) {
                const hLine = document.createElement('div');
                hLine.className = 'line h-line';
                hLine.style.top = `${offset + i * cellSize - 1}px`;
                hLine.style.left = `${offset - 1}px`;
                hLine.style.position = 'absolute';
                hLine.style.width = `${cellSize * (size - 1)}px`;
                hLine.style.height = '2px';
                boardDiv.appendChild(hLine);
            }
            // 画竖线
            for (let i = 0; i < size; i++) {
                const vLine = document.createElement('div');
                vLine.className = 'line v-line';
                vLine.style.left = `${offset + i * cellSize - 1}px`;
                vLine.style.top = `${offset - 1}px`;
                vLine.style.position = 'absolute';
                vLine.style.height = `${cellSize * (size - 1)}px`;
                vLine.style.width = '2px';
                boardDiv.appendChild(vLine);
            }
            // 绑定点击事件
            boardDiv.onclick = handleBoardClick;
            // 画已有棋子
            for (let x = 0; x < size; x++) {
                for (let y = 0; y < size; y++) {
                    if (board[x][y] !== 0) {
                        drawPiece(x, y, board[x][y], lastMove && lastMove.x === x && lastMove.y === y);
                    }
                }
            }
        }

        function drawPiece(x, y, player, isLast) {
            const piece = document.createElement('div');
            piece.className = 'piece ' + (player === 1 ? 'black' : 'white') + (isLast ? ' last' : '');
            piece.style.left = `${offset + y * cellSize}px`;
            piece.style.top = `${offset + x * cellSize}px`;
            boardDiv.appendChild(piece);
        }

        function initBoard() {
            board = Array.from({ length: size }, () => Array(size).fill(0));
            gameOver = false;
            current = 1;
            statusDiv.textContent = '黑棋先手';
            subtitleDiv.textContent = '';
            moveHistory = [];
            undoCount = 0;
            startTime = new Date();
            endTime = null;
            lastMove = null;
            updateRecord();
            drawBoard();
            if (aiInterval) { clearInterval(aiInterval); aiInterval = null; }
            const aiModeControls = document.getElementById('ai-mode-controls');
            const aiControls = document.getElementById('ai-controls');
            if (mode === 'aivai') {
                aiModeControls.style.display = '';
                document.getElementById('ai-toggle-mode').textContent = aiAuto ? '切换为手动下一步' : '切换为自动对战';
                if (aiAuto) {
                    aiControls.style.display = 'none';
                    setTimeout(startAIVsAI, 600);
                } else {
                    aiControls.style.display = '';
                }
            } else {
                aiModeControls.style.display = 'none';
                aiControls.style.display = 'none';
            }
        }

        function aiMove() {
            // 评分法AI：对每个空点分别计算进攻分和防守分，优先选择分数最高的点落子
            let bestScore = -1;
            let bestMoves = [];
            for (let x = 0; x < size; x++) {
                for (let y = 0; y < size; y++) {
                    if (board[x][y] !== 0) continue;
                    // 进攻分（AI为2）
                    let attack = evaluatePoint(x, y, 2);
                    // 防守分（玩家为1）
                    let defend = evaluatePoint(x, y, 1);
                    let score = Math.max(attack, defend * 0.95); // 防守略低于进攻
                    // 若防守分高于进攻分，优先防守
                    if (defend > attack) score = defend;
                    if (score > bestScore) {
                        bestScore = score;
                        bestMoves = [[x, y]];
                    } else if (score === bestScore) {
                        bestMoves.push([x, y]);
                    }
                }
            }
            if (bestMoves.length === 0) return;
            const [x, y] = bestMoves[Math.floor(Math.random() * bestMoves.length)];
            moveHistory.push({ x, y, player: 2 });
            board[x][y] = 2;
            lastMove = { x, y, player: 2 };
            drawBoard();
            updateRecord();
            if (checkWin(x, y, 2)) {
                endTime = new Date();
                showResult('白棋（电脑）获胜！', false);
                gameOver = true;
                return;
            }
            if (isBoardFull()) {
                endTime = new Date();
                showResult('平局！', null, true);
                gameOver = true;
                return;
            }
            current = 1;
            statusDiv.textContent = '黑棋落子';
        }

        // 评分函数：根据连子数和活度给分
        function evaluatePoint(x, y, player) {
            let score = 0;
            const dirs = [
                [1, 0], [0, 1], [1, 1], [1, -1]
            ];
            for (const [dx, dy] of dirs) {
                let count = 1;
                let block = 0;
                // 正向
                for (let d = 1; d < 5; d++) {
                    const nx = x + dx * d, ny = y + dy * d;
                    if (nx < 0 || nx >= size || ny < 0 || ny >= size) { block++; break; }
                    if (board[nx][ny] === player) {
                        count++;
                    } else if (board[nx][ny] === 0) {
                        break;
                    } else {
                        block++;
                        break;
                    }
                }
                // 反向
                for (let d = 1; d < 5; d++) {
                    const nx = x - dx * d, ny = y - dy * d;
                    if (nx < 0 || nx >= size || ny < 0 || ny >= size) { block++; break; }
                    if (board[nx][ny] === player) {
                        count++;
                    } else if (board[nx][ny] === 0) {
                        break;
                    } else {
                        block++;
                        break;
                    }
                }
                // 评分规则
                if (count >= 5) {
                    score += 100000;
                } else if (count === 4 && block === 0) {
                    score += 10000; // 活四
                } else if (count === 4 && block === 1) {
                    score += 1000; // 冲四
                } else if (count === 3 && block === 0) {
                    score += 500; // 活三
                } else if (count === 3 && block === 1) {
                    score += 100; // 眠三
                } else if (count === 2 && block === 0) {
                    score += 50; // 活二
                } else if (count === 2 && block === 1) {
                    score += 10; // 眠二
                }
            }
            return score;
        }

        function handleBoardClick(e) {
            if (gameOver) return;
            const rect = boardDiv.getBoundingClientRect();
            const x = Math.round((e.clientY - rect.top - offset) / cellSize);
            const y = Math.round((e.clientX - rect.left - offset) / cellSize);
            if (x < 0 || x >= size || y < 0 || y >= size) return;
            if (board[x][y] !== 0) return;
            if (mode === 'pvp') {
                moveHistory.push({ x, y, player: current });
                board[x][y] = current;
                lastMove = { x, y, player: current };
                drawBoard();
                updateRecord();
                if (checkWin(x, y, current)) {
                    endTime = new Date();
                    showResult((current === 1 ? '黑棋' : '白棋') + '获胜！', current === 2);
                    gameOver = true;
                    return;
                }
                if (isBoardFull()) {
                    endTime = new Date();
                    showResult('平局！', null, true);
                    gameOver = true;
                    return;
                }
                current = 3 - current;
                statusDiv.textContent = (current === 1 ? '黑棋' : '白棋') + '落子';
            } else if (mode === 'pve') {
                // 玩家只能下黑棋
                if (current !== 1) return;
                moveHistory.push({ x, y, player: 1 });
                board[x][y] = 1;
                lastMove = { x, y, player: 1 };
                drawBoard();
                updateRecord();
                if (checkWin(x, y, 1)) {
                    endTime = new Date();
                    showResult('黑棋（玩家）获胜！', true);
                    gameOver = true;
                    return;
                }
                if (isBoardFull()) {
                    endTime = new Date();
                    showResult('平局！', null, true);
                    gameOver = true;
                    return;
                }
                current = 2;
                statusDiv.textContent = '白棋（电脑）落子';
                setTimeout(() => {
                    if (!gameOver) aiMove();
                }, 400);
            }
        }

        function checkWin(x, y, player) {
            const dirs = [
                [1, 0], [0, 1], [1, 1], [1, -1]
            ];
            for (const [dx, dy] of dirs) {
                let count = 1;
                for (let d = 1; d < 5; d++) {
                    const nx = x + dx * d, ny = y + dy * d;
                    if (nx < 0 || nx >= size || ny < 0 || ny >= size || board[nx][ny] !== player) break;
                    count++;
                }
                for (let d = 1; d < 5; d++) {
                    const nx = x - dx * d, ny = y - dy * d;
                    if (nx < 0 || nx >= size || ny < 0 || ny >= size || board[nx][ny] !== player) break;
                    count++;
                }
                if (count >= 5) return true;
            }
            return false;
        }

        // 悔棋功能（PVP和PVE）
        undoBtn.onclick = function () {
            if (moveHistory.length === 0 || gameOver) return;
            let undoNum = 1;
            if (mode === 'pve' && moveHistory.length >= 2) undoNum = 2;
            for (let i = 0; i < undoNum; i++) {
                const last = moveHistory.pop();
                if (last) board[last.x][last.y] = 0;
            }
            current = mode === 'pve' ? 1 : (moveHistory.length === 0 ? 1 : 3 - moveHistory[moveHistory.length - 1].player);
            lastMove = moveHistory.length > 0 ? moveHistory[moveHistory.length - 1] : null;
            drawBoard();
            updateRecord();
            boardDiv.classList.add('undomove');
            setTimeout(() => { boardDiv.classList.remove('undomove'); }, 400);
            if (mode === 'pve') {
                subtitleDiv.textContent = '人机哥，给个机会';
                undoCount++;
                setTimeout(() => { subtitleDiv.textContent = ''; }, 1500);
            } else {
                undoCount++;
            }
        };

        // 棋谱显示
        function updateRecord() {
            let s = '';
            for (let i = 0; i < moveHistory.length; i++) {
                const m = moveHistory[i];
                s += `${i + 1}. ${m.player === 1 ? '黑' : '白'}(${String.fromCharCode(65 + m.y)}${m.x + 1})  `;
                if ((i + 1) % 4 === 0) s += '\n';
            }
            recordDiv.textContent = s;
        }

        // 结算信息弹窗
        function showResult(msg, playerWin, isDraw) {
            let timeStr = '';
            if (startTime && endTime) {
                const cost = Math.floor((endTime - startTime) / 1000);
                const min = Math.floor(cost / 60);
                const sec = cost % 60;
                timeStr = `对局开始：${startTime.toLocaleTimeString()}\n结束：${endTime.toLocaleTimeString()}\n用时：${min}分${sec}秒  悔棋次数：${undoCount}`;
            }
            let extra = '';
            if (isDraw) {
                alert('平局！\n' + timeStr);
                statusDiv.textContent = '平局！\n' + timeStr;
                return;
            }
            if (mode === 'pve' && !playerWin) {
                extra = '\n啥实力，敢挑战我，菜就多练（摊手）';
            }
            if (mode === 'pve' && playerWin) {
                setTimeout(() => {
                    let userMsg = prompt(msg + '\n' + timeStr + '\n你赢了！可以输入一句话作为字幕：');
                    statusDiv.textContent = msg + (userMsg ? ('\n' + userMsg) : '') + '\n' + timeStr;
                }, 100);
            } else {
                alert(msg + (extra ? '\n' + extra : '') + '\n' + timeStr);
                statusDiv.textContent = msg + (extra ? ('\n' + extra) : '') + '\n' + timeStr;
            }
        }

        function aiMoveFor(player) {
            let bestScore = -1;
            let bestMoves = [];
            for (let x = 0; x < size; x++) {
                for (let y = 0; y < size; y++) {
                    if (board[x][y] !== 0) continue;
                    let attack = evaluatePoint(x, y, player);
                    let defend = evaluatePoint(x, y, 3 - player);
                    let score = 0;
                    if (aiStyle === 'attack') {
                        score = attack + defend * 0.5;
                    } else if (aiStyle === 'defense') {
                        score = defend + attack * 0.5;
                    } else {
                        score = Math.max(attack, defend * 0.95);
                        if (defend > attack) score = defend;
                    }
                    if (score > bestScore) {
                        bestScore = score;
                        bestMoves = [[x, y]];
                    } else if (score === bestScore) {
                        bestMoves.push([x, y]);
                    }
                }
            }
            if (bestMoves.length === 0) return null;
            const [x, y] = bestMoves[Math.floor(Math.random() * bestMoves.length)];
            moveHistory.push({ x, y, player });
            board[x][y] = player;
            lastMove = { x, y, player };
            drawBoard();
            updateRecord();
            if (checkWin(x, y, player)) {
                endTime = new Date();
                showResult((player === 1 ? '黑棋（AI）' : '白棋（AI）') + '获胜！', false);
                gameOver = true;
                return true;
            }
            if (isBoardFull()) {
                endTime = new Date();
                showResult('平局！', null, true);
                gameOver = true;
                return true;
            }
            return false;
        }

        function startAIVsAI() {
            if (aiInterval) clearInterval(aiInterval);
            if (!aiAuto) return;
            aiInterval = setInterval(() => {
                if (!aiAuto) { clearInterval(aiInterval); aiInterval = null; return; }
                if (gameOver) { clearInterval(aiInterval); aiInterval = null; return; }
                let win = aiMoveFor(current);
                if (win) { clearInterval(aiInterval); aiInterval = null; return; }
                current = 3 - current;
            }, aiSpeed);
        }

        modeSelect.onchange = function () {
            mode = modeSelect.value;
            initBoard();
        };
        restartBtn.onclick = initBoard;
        document.getElementById('size-select').onchange = function () {
            size = parseInt(this.value);
            offset = cellSize / 2;
            initBoard();
        };
        initBoard();
        updateBoardSize();
        window.addEventListener('beforeunload', function () { if (aiInterval) clearInterval(aiInterval); });

        // 判断棋盘是否已满
        function isBoardFull() {
            for (let x = 0; x < size; x++) {
                for (let y = 0; y < size; y++) {
                    if (board[x][y] === 0) return false;
                }
            }
            return true;
        }

        // AI对战模式切换
        document.getElementById('ai-toggle-mode').onclick = function () {
            aiAuto = !aiAuto;
            initBoard();
        };
        // AI手动下一步
        document.getElementById('ai-next').onclick = function () {
            if (gameOver) return;
            let win = aiMoveFor(current);
            if (!win) current = 3 - current;
        };
        // AI加速/减速
        document.getElementById('ai-speed').onclick = function () {
            if (aiSpeed === 400) {
                aiSpeed = 100;
                this.textContent = '减速';
            } else {
                aiSpeed = 400;
                this.textContent = '加速';
            }
            if (aiInterval) { clearInterval(aiInterval); aiInterval = null; }
            if (mode === 'aivai' && aiAuto && !gameOver) startAIVsAI();
        };
        // AI风格切换
        document.getElementById('ai-style').onchange = function () {
            aiStyle = this.value;
        };
    </script>
</body>

</html>